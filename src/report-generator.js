// Add this to your improved-nlp-processor.js or as a separate module

export function generateReport(issues, reportType) {
  const now = new Date().toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  });
  
  switch(reportType) {
    case 'sprint':
      return generateSprintReport(issues, now);
    case 'bug':
      return generateBugReport(issues, now);
    case 'status':
      return generateStatusReport(issues, now);
    case 'pi':
      return generatePIReport(issues, now);
    default:
      return generateGenericReport(issues, now);
  }
}

function generateSprintReport(issues, date) {
  const byStatus = {};
  const byType = {};
  const byAssignee = {};
  
  issues.forEach(issue => {
    const status = issue.fields.status.name;
    const type = issue.fields.issuetype.name;
    const assignee = issue.fields.assignee?.displayName || 'Unassigned';
    
    byStatus[status] = (byStatus[status] || 0) + 1;
    byType[type] = (byType[type] || 0) + 1;
    byAssignee[assignee] = (byAssignee[assignee] || 0) + 1;
  });
  
  let html = `
<h1>Sprint Report - ${date}</h1>

<h2>Summary</h2>
<p>Total issues in sprint: <strong>${issues.length}</strong></p>

<h2>Status Breakdown</h2>
<table>
  <thead>
    <tr>
      <th>Status</th>
      <th>Count</th>
      <th>Percentage</th>
    </tr>
  </thead>
  <tbody>
    ${Object.entries(byStatus).map(([status, count]) => `
    <tr>
      <td>${status}</td>
      <td>${count}</td>
      <td>${Math.round(count/issues.length * 100)}%</td>
    </tr>`).join('')}
  </tbody>
</table>

<h2>Issue Type Distribution</h2>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Count</th>
    </tr>
  </thead>
  <tbody>
    ${Object.entries(byType).map(([type, count]) => `
    <tr>
      <td>${type}</td>
      <td>${count}</td>
    </tr>`).join('')}
  </tbody>
</table>

<h2>Team Workload</h2>
<table>
  <thead>
    <tr>
      <th>Assignee</th>
      <th>Issues</th>
    </tr>
  </thead>
  <tbody>
    ${Object.entries(byAssignee)
      .sort((a, b) => b[1] - a[1])
      .map(([assignee, count]) => `
    <tr>
      <td>${assignee}</td>
      <td>${count}</td>
    </tr>`).join('')}
  </tbody>
</table>

<h2>Issue Details</h2>
<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Summary</th>
      <th>Type</th>
      <th>Status</th>
      <th>Assignee</th>
    </tr>
  </thead>
  <tbody>
    ${issues.map(issue => `
    <tr>
      <td><a href="https://kofadam.atlassian.net/browse/${issue.key}">${issue.key}</a></td>
      <td>${issue.fields.summary}</td>
      <td>${issue.fields.issuetype.name}</td>
      <td>${issue.fields.status.name}</td>
      <td>${issue.fields.assignee?.displayName || 'Unassigned'}</td>
    </tr>`).join('')}
  </tbody>
</table>

<hr/>
<p><em>Generated by Atlassian AI Assistant on ${date}</em></p>
`;

  return {
    title: `Sprint Report - ${date}`,
    content: html,
    format: 'storage' // Confluence storage format
  };
}

function generateBugReport(issues, date) {
  const bugs = issues.filter(i => i.fields.issuetype.name === 'Bug');
  const byPriority = {};
  const byStatus = {};
  
  bugs.forEach(bug => {
    const priority = bug.fields.priority?.name || 'None';
    const status = bug.fields.status.name;
    byPriority[priority] = (byPriority[priority] || 0) + 1;
    byStatus[status] = (byStatus[status] || 0) + 1;
  });

  let html = `
<h1>Bug Report - ${date}</h1>

<h2>Overview</h2>
<p>Total bugs: <strong>${bugs.length}</strong></p>

<h2>Priority Distribution</h2>
<table>
  <thead>
    <tr>
      <th>Priority</th>
      <th>Count</th>
      <th>Status</th>
    </tr>
  </thead>
  <tbody>
    ${['Highest', 'High', 'Medium', 'Low'].map(priority => {
      const count = byPriority[priority] || 0;
      if (count === 0) return '';
      return `
    <tr style="background-color: ${
      priority === 'Highest' ? '#ffebe6' : 
      priority === 'High' ? '#fff4e6' : 
      'white'
    }">
      <td><strong>${priority}</strong></td>
      <td>${count}</td>
      <td>${count > 0 ? 'âš ï¸ Needs attention' : 'âœ…'}</td>
    </tr>`;
    }).join('')}
  </tbody>
</table>

<h2>Critical & High Priority Bugs</h2>
${bugs.filter(b => ['Highest', 'High'].includes(b.fields.priority?.name))
  .map(bug => `
<div style="border-left: 3px solid red; padding-left: 10px; margin: 10px 0;">
  <strong>${bug.key}</strong>: ${bug.fields.summary}<br/>
  Status: ${bug.fields.status.name} | 
  Created: ${new Date(bug.fields.created).toLocaleDateString()}
</div>`).join('')}

<h2>All Bugs</h2>
<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Summary</th>
      <th>Priority</th>
      <th>Status</th>
      <th>Created</th>
    </tr>
  </thead>
  <tbody>
    ${bugs.map(bug => `
    <tr>
      <td><a href="https://kofadam.atlassian.net/browse/${bug.key}">${bug.key}</a></td>
      <td>${bug.fields.summary}</td>
      <td>${bug.fields.priority?.name || 'None'}</td>
      <td>${bug.fields.status.name}</td>
      <td>${new Date(bug.fields.created).toLocaleDateString()}</td>
    </tr>`).join('')}
  </tbody>
</table>

<hr/>
<p><em>Generated by Atlassian AI Assistant on ${date}</em></p>
`;

  return {
    title: `Bug Report - ${date}`,
    content: html,
    format: 'storage'
  };
}

function generateStatusReport(issues, date) {
  const stats = {
    total: issues.length,
    todo: issues.filter(i => i.fields.status.name === 'To Do').length,
    inProgress: issues.filter(i => i.fields.status.name === 'In Progress').length,
    done: issues.filter(i => i.fields.status.name === 'Done').length
  };
  
  const completionRate = Math.round((stats.done / stats.total) * 100);
  
  let html = `
<h1>Project Status Report - ${date}</h1>

<h2>Executive Summary</h2>
<p>Project completion: <strong>${completionRate}%</strong></p>

<h2>Status Overview</h2>
<table>
  <thead>
    <tr>
      <th>Status</th>
      <th>Count</th>
      <th>Percentage</th>
      <th>Visual</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>To Do</td>
      <td>${stats.todo}</td>
      <td>${Math.round(stats.todo/stats.total * 100)}%</td>
      <td>${'â¬œ'.repeat(Math.round(stats.todo/stats.total * 10))}</td>
    </tr>
    <tr>
      <td>In Progress</td>
      <td>${stats.inProgress}</td>
      <td>${Math.round(stats.inProgress/stats.total * 100)}%</td>
      <td>${'ğŸŸ¦'.repeat(Math.round(stats.inProgress/stats.total * 10))}</td>
    </tr>
    <tr>
      <td>Done</td>
      <td>${stats.done}</td>
      <td>${Math.round(stats.done/stats.total * 100)}%</td>
      <td>${'âœ…'.repeat(Math.round(stats.done/stats.total * 10))}</td>
    </tr>
  </tbody>
</table>

<h2>Recent Activity</h2>
${issues.slice(0, 5).map(issue => `
<div style="margin: 10px 0;">
  <strong>${issue.key}</strong>: ${issue.fields.summary}<br/>
  Status: ${issue.fields.status.name} | 
  Type: ${issue.fields.issuetype.name} |
  Updated: ${new Date(issue.fields.updated).toLocaleDateString()}
</div>`).join('')}

<h2>Metrics</h2>
<ul>
  <li>Total Issues: ${stats.total}</li>
  <li>Completion Rate: ${completionRate}%</li>
  <li>In Progress: ${stats.inProgress}</li>
  <li>Blocked: ${issues.filter(i => i.fields.labels?.includes('blocked')).length}</li>
</ul>

<hr/>
<p><em>Generated by Atlassian AI Assistant on ${date}</em></p>
`;

  return {
    title: `Status Report - ${date}`,
    content: html,
    format: 'storage'
  };
}

function generateGenericReport(issues, date) {
  return generateStatusReport(issues, date);
}

function generatePIReport(issues, date) {
  // Extract PI version from labels
  const piLabel = issues.find(i => i.fields.labels?.some(l => l.startsWith('PI-')))
    ?.fields.labels?.find(l => l.startsWith('PI-'));
  const piVersion = piLabel ? piLabel.replace('PI-', '') : 'Unknown';

  // Categorize issues by type
  const objectives = issues.filter(i => i.fields.labels?.includes('PI-Objective'));
  const features = issues.filter(i => i.fields.labels?.includes('Feature'));
  const risks = issues.filter(i => i.fields.labels?.includes('Risk'));

  // Group risks by ROAM status
  const risksByROAM = {
    'Resolved': risks.filter(r => r.fields.labels?.includes('ROAM-Resolved')),
    'Owned': risks.filter(r => r.fields.labels?.includes('ROAM-Owned')),
    'Accepted': risks.filter(r => r.fields.labels?.includes('ROAM-Accepted')),
    'Mitigated': risks.filter(r => r.fields.labels?.includes('ROAM-Mitigated'))
  };

  // Calculate feature story points total
  const totalStoryPoints = features.reduce((sum, f) => {
    const description = f.fields.description || '';
    const spMatch = description.match(/\*\*Story Points:\*\*\s*(\d+)/);
    return sum + (spMatch ? parseInt(spMatch[1]) : 0);
  }, 0);

  let html = `
<h1>Program Increment ${piVersion} Report</h1>
<p><em>Generated on ${date}</em></p>

<h2>Executive Summary</h2>
<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>Count</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>PI Objectives</td>
      <td><strong>${objectives.length}</strong></td>
    </tr>
    <tr>
      <td>Features/Capabilities</td>
      <td><strong>${features.length}</strong></td>
    </tr>
    <tr>
      <td>Total Story Points</td>
      <td><strong>${totalStoryPoints}</strong></td>
    </tr>
    <tr>
      <td>Identified Risks</td>
      <td><strong>${risks.length}</strong></td>
    </tr>
    <tr>
      <td>Resolved Risks</td>
      <td><strong>${risksByROAM.Resolved.length}</strong></td>
    </tr>
  </tbody>
</table>

<h2>PI Objectives</h2>
${objectives.length > 0 ? `
<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Objective</th>
      <th>Business Value</th>
    </tr>
  </thead>
  <tbody>
    ${objectives.map(obj => {
      const description = obj.fields.description || '';
      const bvMatch = description.match(/\*\*Business Value:\*\*\s*(\d+)\/10/);
      const businessValue = bvMatch ? bvMatch[1] : 'N/A';
      return `
    <tr>
      <td><a href="https://kofadam.atlassian.net/browse/${obj.key}">${obj.key}</a></td>
      <td>${obj.fields.summary.replace(/^PI \d+\.\d+ Objective:\s*/, '')}</td>
      <td>${businessValue}/10</td>
    </tr>`;
    }).join('')}
  </tbody>
</table>
` : '<p><em>No objectives defined for this PI</em></p>'}

<h2>Features & Capabilities</h2>
${features.length > 0 ? `
<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Feature</th>
      <th>Story Points</th>
      <th>Status</th>
    </tr>
  </thead>
  <tbody>
    ${features.map(feature => {
      const description = feature.fields.description || '';
      const spMatch = description.match(/\*\*Story Points:\*\*\s*(\d+)/);
      const storyPoints = spMatch ? spMatch[1] : '-';
      return `
    <tr>
      <td><a href="https://kofadam.atlassian.net/browse/${feature.key}">${feature.key}</a></td>
      <td>${feature.fields.summary.replace(/^Feature:\s*/, '')}</td>
      <td>${storyPoints}</td>
      <td>${feature.fields.status.name}</td>
    </tr>`;
    }).join('')}
  </tbody>
</table>
<p><strong>Total Planned Story Points:</strong> ${totalStoryPoints}</p>
` : '<p><em>No features defined for this PI</em></p>'}

<h2>Risks & ROAM Status</h2>
${risks.length > 0 ? `
<div>
${Object.entries(risksByROAM).map(([status, riskList]) => {
  if (riskList.length === 0) return '';
  const statusColor = {
    'Resolved': '#e3fcef',
    'Owned': '#fff4e6',
    'Accepted': '#fff0f0',
    'Mitigated': '#f0f5ff'
  }[status];
  const statusIcon = {
    'Resolved': 'âœ…',
    'Owned': 'ğŸ‘¤',
    'Accepted': 'âš ï¸',
    'Mitigated': 'ğŸ›¡ï¸'
  }[status];

  return `
<h3>${statusIcon} ${status} Risks (${riskList.length})</h3>
<table style="background-color: ${statusColor}">
  <thead>
    <tr>
      <th>Key</th>
      <th>Risk Description</th>
      <th>Priority</th>
    </tr>
  </thead>
  <tbody>
    ${riskList.map(risk => `
    <tr>
      <td><a href="https://kofadam.atlassian.net/browse/${risk.key}">${risk.key}</a></td>
      <td>${risk.fields.summary.replace(/^Risk:\s*/, '')}</td>
      <td>${risk.fields.priority?.name || 'Medium'}</td>
    </tr>`).join('')}
  </tbody>
</table>
`;
}).join('')}
</div>

<h3>ROAM Distribution</h3>
<table>
  <thead>
    <tr>
      <th>Status</th>
      <th>Count</th>
      <th>Percentage</th>
    </tr>
  </thead>
  <tbody>
    ${Object.entries(risksByROAM).map(([status, riskList]) => `
    <tr>
      <td>${status}</td>
      <td>${riskList.length}</td>
      <td>${Math.round((riskList.length / risks.length) * 100)}%</td>
    </tr>`).join('')}
  </tbody>
</table>
` : '<p><em>No risks identified for this PI</em></p>'}

<h2>Recommendations</h2>
<ul>
  ${risksByROAM.Owned.length > 0 ? `<li>âš ï¸ <strong>${risksByROAM.Owned.length} risks are Owned</strong> - ensure mitigation plans are in place</li>` : ''}
  ${risksByROAM.Accepted.length > 0 ? `<li>âš ï¸ <strong>${risksByROAM.Accepted.length} risks are Accepted</strong> - monitor closely for impact</li>` : ''}
  ${totalStoryPoints > 0 ? `<li>ğŸ“Š Total planned capacity: <strong>${totalStoryPoints} story points</strong></li>` : ''}
  ${risksByROAM.Resolved.length === risks.length && risks.length > 0 ? '<li>âœ… All risks have been resolved - excellent risk management!</li>' : ''}
</ul>

<hr/>
<p><em>Generated by Atlassian AI Assistant on ${date}</em></p>
`;

  return {
    title: `PI ${piVersion} Report - ${date}`,
    content: html,
    format: 'storage'
  };
}

// Add this function to handle report generation requests in your NLP processor
export function detectReportIntent(query) {
  const lowerQuery = query.toLowerCase();

  const reportPatterns = [
    // PI report patterns (check first for specificity)
    { pattern: /(?:create|generate|make|show)(?:\s+a)?\s+(?:PI|program increment)\s+(\d+\.\d+)\s+report/i, type: 'pi' },
    { pattern: /(?:create|generate|make)(?:\s+a)?\s+report\s+(?:of|for)\s+(?:PI|program increment)\s+(\d+\.\d+)/i, type: 'pi' },
    { pattern: /(?:×™×™×¦×¨|×¦×•×¨|×ª×™×™×¦×¨|×ª×Ÿ ×œ×™|×”×›×Ÿ)(?:\s+×œ×™)?(?:\s+××ª)?\s+×“×•×—\s+PI\s+(\d+\.\d+)/i, type: 'pi' },

    // English patterns
    { pattern: /(?:create|generate|make)(?:\s+a)?\s+report\s+(?:of|for)\s+(?:all\s+)?(?:future|upcoming)\s+sprints?\s+(?:in progress\s+)?tasks?/i, type: 'future-sprints' },
    { pattern: /generate (?:a )?(?:sprint \d+ |sprint )?report/i, type: 'sprint' },
    { pattern: /create (?:a )?bug report/i, type: 'bug' },
    { pattern: /make (?:a )?status report/i, type: 'status' },
    { pattern: /publish (?:a )?report to confluence/i, type: 'generic' },
    { pattern: /create (?:a )?summary (?:in|for|to) confluence/i, type: 'status' },

    // Hebrew patterns - ×“×•×— (report), ×™×™×¦×¨/×¦×•×¨ (generate/create)
    { pattern: /(?:×™×™×¦×¨|×¦×•×¨|×ª×™×™×¦×¨|×ª×•×›×œ ×œ×™×™×¦×¨|××¤×©×¨ ×œ×™×™×¦×¨|×ª×Ÿ ×œ×™|×”×›×Ÿ)(?:\s+×œ×™)?(?:\s+××ª)?\s+×“×•×—(?:\s+×©×œ)?\s+(?:×¡×¤×¨×™× ×˜×™× ×¢×ª×™×“×™×™×|×›×œ ×”×¡×¤×¨×™× ×˜×™× ×”×¢×ª×™×“×™×™×)/i, type: 'future-sprints' },
    { pattern: /(?:×™×™×¦×¨|×¦×•×¨|×ª×™×™×¦×¨|×ª×•×›×œ ×œ×™×™×¦×¨|××¤×©×¨ ×œ×™×™×¦×¨|×ª×Ÿ ×œ×™|×”×›×Ÿ)(?:\s+×œ×™)?(?:\s+××ª)?\s+×“×•×—(?:\s+×©×œ)?\s+×¡×¤×¨×™× ×˜/i, type: 'sprint' },
    { pattern: /(?:×™×™×¦×¨|×¦×•×¨|×ª×™×™×¦×¨|×ª×•×›×œ ×œ×™×™×¦×¨|××¤×©×¨ ×œ×™×™×¦×¨|×ª×Ÿ ×œ×™|×”×›×Ÿ)(?:\s+×œ×™)?(?:\s+××ª)?\s+×“×•×—(?:\s+×©×œ)?\s+(?:×‘××’×™×|×‘××’×¡|×ª×§×œ×•×ª)/i, type: 'bug' },
    { pattern: /(?:×™×™×¦×¨|×¦×•×¨|×ª×™×™×¦×¨|×ª×•×›×œ ×œ×™×™×¦×¨|××¤×©×¨ ×œ×™×™×¦×¨|×ª×Ÿ ×œ×™|×”×›×Ÿ)(?:\s+×œ×™)?(?:\s+××ª)?\s+×“×•×—(?:\s+×©×œ)?\s+(?:×¡×˜×˜×•×¡|××¦×‘|×”×ª×§×“××•×ª)/i, type: 'status' },
    { pattern: /(?:×¤×¨×¡×|×¤×¨×¡×•×|×”×¢×œ×”|×”×¢×œ××”)(?:\s+××ª)?\s+×“×•×—\s+×œ[\s-]?confluence/i, type: 'generic' },
    { pattern: /×“×•×—\s+×¡×¤×¨×™× ×˜/i, type: 'sprint' },
    { pattern: /×“×•×—\s+×‘××’×™×/i, type: 'bug' },
    { pattern: /×“×•×—\s+×¡×˜×˜×•×¡/i, type: 'status' }
  ];

  for (const { pattern, type } of reportPatterns) {
    if (pattern.test(query)) {
      return {
        intent: 'generateReport',
        reportType: type,
        shouldPublish: lowerQuery.includes('confluence') || query.includes('×§×•× ×¤×œ×•×× ×¡') || lowerQuery.includes('publish') || query.includes('×¤×¨×¡×')
      };
    }
  }

  return null;
}