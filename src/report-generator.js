// Add this to your improved-nlp-processor.js or as a separate module

export function generateReport(issues, reportType) {
  const now = new Date().toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  });
  
  switch(reportType) {
    case 'sprint':
      return generateSprintReport(issues, now);
    case 'bug':
      return generateBugReport(issues, now);
    case 'status':
      return generateStatusReport(issues, now);
    default:
      return generateGenericReport(issues, now);
  }
}

function generateSprintReport(issues, date) {
  const byStatus = {};
  const byType = {};
  const byAssignee = {};
  
  issues.forEach(issue => {
    const status = issue.fields.status.name;
    const type = issue.fields.issuetype.name;
    const assignee = issue.fields.assignee?.displayName || 'Unassigned';
    
    byStatus[status] = (byStatus[status] || 0) + 1;
    byType[type] = (byType[type] || 0) + 1;
    byAssignee[assignee] = (byAssignee[assignee] || 0) + 1;
  });
  
  let html = `
<h1>Sprint Report - ${date}</h1>

<h2>Summary</h2>
<p>Total issues in sprint: <strong>${issues.length}</strong></p>

<h2>Status Breakdown</h2>
<table>
  <thead>
    <tr>
      <th>Status</th>
      <th>Count</th>
      <th>Percentage</th>
    </tr>
  </thead>
  <tbody>
    ${Object.entries(byStatus).map(([status, count]) => `
    <tr>
      <td>${status}</td>
      <td>${count}</td>
      <td>${Math.round(count/issues.length * 100)}%</td>
    </tr>`).join('')}
  </tbody>
</table>

<h2>Issue Type Distribution</h2>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Count</th>
    </tr>
  </thead>
  <tbody>
    ${Object.entries(byType).map(([type, count]) => `
    <tr>
      <td>${type}</td>
      <td>${count}</td>
    </tr>`).join('')}
  </tbody>
</table>

<h2>Team Workload</h2>
<table>
  <thead>
    <tr>
      <th>Assignee</th>
      <th>Issues</th>
    </tr>
  </thead>
  <tbody>
    ${Object.entries(byAssignee)
      .sort((a, b) => b[1] - a[1])
      .map(([assignee, count]) => `
    <tr>
      <td>${assignee}</td>
      <td>${count}</td>
    </tr>`).join('')}
  </tbody>
</table>

<h2>Issue Details</h2>
<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Summary</th>
      <th>Type</th>
      <th>Status</th>
      <th>Assignee</th>
    </tr>
  </thead>
  <tbody>
    ${issues.map(issue => `
    <tr>
      <td><a href="https://kofadam.atlassian.net/browse/${issue.key}">${issue.key}</a></td>
      <td>${issue.fields.summary}</td>
      <td>${issue.fields.issuetype.name}</td>
      <td>${issue.fields.status.name}</td>
      <td>${issue.fields.assignee?.displayName || 'Unassigned'}</td>
    </tr>`).join('')}
  </tbody>
</table>

<hr/>
<p><em>Generated by Atlassian AI Assistant on ${date}</em></p>
`;

  return {
    title: `Sprint Report - ${date}`,
    content: html,
    format: 'storage' // Confluence storage format
  };
}

function generateBugReport(issues, date) {
  const bugs = issues.filter(i => i.fields.issuetype.name === 'Bug');
  const byPriority = {};
  const byStatus = {};
  
  bugs.forEach(bug => {
    const priority = bug.fields.priority?.name || 'None';
    const status = bug.fields.status.name;
    byPriority[priority] = (byPriority[priority] || 0) + 1;
    byStatus[status] = (byStatus[status] || 0) + 1;
  });

  let html = `
<h1>Bug Report - ${date}</h1>

<h2>Overview</h2>
<p>Total bugs: <strong>${bugs.length}</strong></p>

<h2>Priority Distribution</h2>
<table>
  <thead>
    <tr>
      <th>Priority</th>
      <th>Count</th>
      <th>Status</th>
    </tr>
  </thead>
  <tbody>
    ${['Highest', 'High', 'Medium', 'Low'].map(priority => {
      const count = byPriority[priority] || 0;
      if (count === 0) return '';
      return `
    <tr style="background-color: ${
      priority === 'Highest' ? '#ffebe6' : 
      priority === 'High' ? '#fff4e6' : 
      'white'
    }">
      <td><strong>${priority}</strong></td>
      <td>${count}</td>
      <td>${count > 0 ? '⚠️ Needs attention' : '✅'}</td>
    </tr>`;
    }).join('')}
  </tbody>
</table>

<h2>Critical & High Priority Bugs</h2>
${bugs.filter(b => ['Highest', 'High'].includes(b.fields.priority?.name))
  .map(bug => `
<div style="border-left: 3px solid red; padding-left: 10px; margin: 10px 0;">
  <strong>${bug.key}</strong>: ${bug.fields.summary}<br/>
  Status: ${bug.fields.status.name} | 
  Created: ${new Date(bug.fields.created).toLocaleDateString()}
</div>`).join('')}

<h2>All Bugs</h2>
<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Summary</th>
      <th>Priority</th>
      <th>Status</th>
      <th>Created</th>
    </tr>
  </thead>
  <tbody>
    ${bugs.map(bug => `
    <tr>
      <td><a href="https://kofadam.atlassian.net/browse/${bug.key}">${bug.key}</a></td>
      <td>${bug.fields.summary}</td>
      <td>${bug.fields.priority?.name || 'None'}</td>
      <td>${bug.fields.status.name}</td>
      <td>${new Date(bug.fields.created).toLocaleDateString()}</td>
    </tr>`).join('')}
  </tbody>
</table>

<hr/>
<p><em>Generated by Atlassian AI Assistant on ${date}</em></p>
`;

  return {
    title: `Bug Report - ${date}`,
    content: html,
    format: 'storage'
  };
}

function generateStatusReport(issues, date) {
  const stats = {
    total: issues.length,
    todo: issues.filter(i => i.fields.status.name === 'To Do').length,
    inProgress: issues.filter(i => i.fields.status.name === 'In Progress').length,
    done: issues.filter(i => i.fields.status.name === 'Done').length
  };
  
  const completionRate = Math.round((stats.done / stats.total) * 100);
  
  let html = `
<h1>Project Status Report - ${date}</h1>

<h2>Executive Summary</h2>
<p>Project completion: <strong>${completionRate}%</strong></p>

<h2>Status Overview</h2>
<table>
  <thead>
    <tr>
      <th>Status</th>
      <th>Count</th>
      <th>Percentage</th>
      <th>Visual</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>To Do</td>
      <td>${stats.todo}</td>
      <td>${Math.round(stats.todo/stats.total * 100)}%</td>
      <td>${'⬜'.repeat(Math.round(stats.todo/stats.total * 10))}</td>
    </tr>
    <tr>
      <td>In Progress</td>
      <td>${stats.inProgress}</td>
      <td>${Math.round(stats.inProgress/stats.total * 100)}%</td>
      <td>${'🟦'.repeat(Math.round(stats.inProgress/stats.total * 10))}</td>
    </tr>
    <tr>
      <td>Done</td>
      <td>${stats.done}</td>
      <td>${Math.round(stats.done/stats.total * 100)}%</td>
      <td>${'✅'.repeat(Math.round(stats.done/stats.total * 10))}</td>
    </tr>
  </tbody>
</table>

<h2>Recent Activity</h2>
${issues.slice(0, 5).map(issue => `
<div style="margin: 10px 0;">
  <strong>${issue.key}</strong>: ${issue.fields.summary}<br/>
  Status: ${issue.fields.status.name} | 
  Type: ${issue.fields.issuetype.name} |
  Updated: ${new Date(issue.fields.updated).toLocaleDateString()}
</div>`).join('')}

<h2>Metrics</h2>
<ul>
  <li>Total Issues: ${stats.total}</li>
  <li>Completion Rate: ${completionRate}%</li>
  <li>In Progress: ${stats.inProgress}</li>
  <li>Blocked: ${issues.filter(i => i.fields.labels?.includes('blocked')).length}</li>
</ul>

<hr/>
<p><em>Generated by Atlassian AI Assistant on ${date}</em></p>
`;

  return {
    title: `Status Report - ${date}`,
    content: html,
    format: 'storage'
  };
}

function generateGenericReport(issues, date) {
  return generateStatusReport(issues, date);
}

// Add this function to handle report generation requests in your NLP processor
export function detectReportIntent(query) {
  const lowerQuery = query.toLowerCase();

  const reportPatterns = [
    // English patterns
    { pattern: /(?:create|generate|make)(?:\s+a)?\s+report\s+(?:of|for)\s+(?:all\s+)?(?:future|upcoming)\s+sprints?\s+(?:in progress\s+)?tasks?/i, type: 'future-sprints' },
    { pattern: /generate (?:a )?(?:sprint \d+ |sprint )?report/i, type: 'sprint' },
    { pattern: /create (?:a )?bug report/i, type: 'bug' },
    { pattern: /make (?:a )?status report/i, type: 'status' },
    { pattern: /publish (?:a )?report to confluence/i, type: 'generic' },
    { pattern: /create (?:a )?summary (?:in|for|to) confluence/i, type: 'status' },

    // Hebrew patterns - דוח (report), ייצר/צור (generate/create)
    { pattern: /(?:ייצר|צור|תייצר|תוכל לייצר|אפשר לייצר|תן לי|הכן)(?:\s+לי)?(?:\s+את)?\s+דוח(?:\s+של)?\s+(?:ספרינטים עתידיים|כל הספרינטים העתידיים)/i, type: 'future-sprints' },
    { pattern: /(?:ייצר|צור|תייצר|תוכל לייצר|אפשר לייצר|תן לי|הכן)(?:\s+לי)?(?:\s+את)?\s+דוח(?:\s+של)?\s+ספרינט/i, type: 'sprint' },
    { pattern: /(?:ייצר|צור|תייצר|תוכל לייצר|אפשר לייצר|תן לי|הכן)(?:\s+לי)?(?:\s+את)?\s+דוח(?:\s+של)?\s+(?:באגים|באגס|תקלות)/i, type: 'bug' },
    { pattern: /(?:ייצר|צור|תייצר|תוכל לייצר|אפשר לייצר|תן לי|הכן)(?:\s+לי)?(?:\s+את)?\s+דוח(?:\s+של)?\s+(?:סטטוס|מצב|התקדמות)/i, type: 'status' },
    { pattern: /(?:פרסם|פרסום|העלה|העלאה)(?:\s+את)?\s+דוח\s+ל[\s-]?confluence/i, type: 'generic' },
    { pattern: /דוח\s+ספרינט/i, type: 'sprint' },
    { pattern: /דוח\s+באגים/i, type: 'bug' },
    { pattern: /דוח\s+סטטוס/i, type: 'status' }
  ];

  for (const { pattern, type } of reportPatterns) {
    if (pattern.test(query)) {
      return {
        intent: 'generateReport',
        reportType: type,
        shouldPublish: lowerQuery.includes('confluence') || query.includes('קונפלואנס') || lowerQuery.includes('publish') || query.includes('פרסם')
      };
    }
  }

  return null;
}